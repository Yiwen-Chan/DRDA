package main

import (
	"bytes"
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net"
)

const (
	// DRDA (Exchange Server Attributes)
	EXCSAT   = 0x1041 // DDM (EXCSAT)
	EXTNAM   = 0x115e // Parameter (External Name)
	MGRLVLLS = 0x1404 // Parameter (Manager-Level List)
	SRVCLSNM = 0x1147 // Parameter (Server Class Name)
	SRVNAM   = 0x116d // Parameter (Server Name)
	SRVRLSLV = 0x115a // Parameter (Server Product Release Level)

	// DRDA (Access Security)
	ACCSEC = 0x106d // DDM (ACCSEC)
	SECMEC = 0x11a2 // Parameter (Security Mechanism)
	RDBNAM = 0x2110 // Parameter (Relational Database Name)
	SECTKN = 0x11dc // Parameter (Security Token)
)

var ebcdic = [256]byte{
	0, 1, 2, 3, 55, 45, 46, 47, 22, 5, 37, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 60, 61, 50, 38, 24, 25, 63, 39, 28, 29, 30, 31,
	64, 79, 127, 123, 91, 108, 80, 125, 77, 93, 92, 78, 107, 96, 75, 97,
	240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 122, 94, 76, 126, 110, 111,
	124, 193, 194, 195, 196, 197, 198, 199, 200, 201, 209, 210, 211, 212, 213, 214,
	215, 216, 217, 226, 227, 228, 229, 230, 231, 232, 233, 74, 224, 90, 95, 109,
	121, 129, 130, 131, 132, 133, 134, 135, 136, 137, 145, 146, 147, 148, 149, 150,
	151, 152, 153, 162, 163, 164, 165, 166, 167, 168, 169, 192, 106, 208, 161, 7,
	32, 33, 34, 35, 36, 21, 6, 23, 40, 41, 42, 43, 44, 9, 10, 27,
	48, 49, 26, 51, 52, 53, 54, 8, 56, 57, 58, 59, 4, 20, 62, 225,
	65, 66, 67, 68, 69, 70, 71, 72, 73, 81, 82, 83, 84, 85, 86, 87,
	88, 89, 98, 99, 100, 101, 102, 103, 104, 105, 112, 113, 114, 115, 116, 117,
	118, 119, 120, 128, 138, 139, 140, 141, 142, 143, 144, 154, 155, 156, 157, 158,
	159, 160, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
	184, 185, 186, 187, 188, 189, 190, 191, 202, 203, 204, 205, 206, 207, 218, 219,
	220, 221, 222, 223, 234, 235, 236, 237, 238, 239, 250, 251, 252, 253, 254, 255,
}

var ascii = [256]byte{
	0, 1, 2, 3, 156, 9, 134, 127, 151, 141, 142, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 157, 133, 8, 135, 24, 25, 146, 143, 28, 29, 30, 31,
	128, 129, 130, 131, 132, 10, 23, 27, 136, 137, 138, 139, 140, 5, 6, 7,
	144, 145, 22, 147, 148, 149, 150, 4, 152, 153, 154, 155, 20, 21, 158, 26,
	32, 160, 161, 162, 163, 164, 165, 166, 167, 168, 91, 46, 60, 40, 43, 33,
	38, 169, 170, 171, 172, 173, 174, 175, 176, 177, 93, 36, 42, 41, 59, 94,
	45, 47, 178, 179, 180, 181, 182, 183, 184, 185, 124, 44, 37, 95, 62, 63,
	186, 187, 188, 189, 190, 191, 192, 193, 194, 96, 58, 35, 64, 39, 61, 34,
	195, 97, 98, 99, 100, 101, 102, 103, 104, 105, 196, 197, 198, 199, 200, 201,
	202, 106, 107, 108, 109, 110, 111, 112, 113, 114, 203, 204, 205, 206, 207, 208,
	209, 126, 115, 116, 117, 118, 119, 120, 121, 122, 210, 211, 212, 213, 214, 215,
	216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231,
	123, 65, 66, 67, 68, 69, 70, 71, 72, 73, 232, 233, 234, 235, 236, 237,
	125, 74, 75, 76, 77, 78, 79, 80, 81, 82, 238, 239, 240, 241, 242, 243,
	92, 159, 83, 84, 85, 86, 87, 88, 89, 90, 244, 245, 246, 247, 248, 249,
	48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 250, 251, 252, 253, 254, 255,
}

type Login struct {
	//Login    xml.Name `xml:"login"`
	Username struct {
		Name string `xml:"name"`
		Sex  string `xml:"sex"`
	} `xml:"username"`
	Password string `xml:"password"`
}

type Request interface {
	Unmarshal(data []byte) error
}

func (r *Login) Unmarshal(data []byte) error {
	decoder := xml.NewDecoder(bytes.NewReader(data))
	decoder.CharsetReader = func(charset string, input io.Reader) (io.Reader, error) {
		b, err := ioutil.ReadAll(input)
		if err != nil {
			return nil, err
		}
		b = bytes.TrimLeft(b, "	")
		return bytes.NewReader(b), nil
	}
	return xml.Unmarshal(data, r)
}

func NetHandle(data []byte, request Request, handles ...func(request Request)) {
	err := request.Unmarshal(data)
	if err != nil {
		panic(err)
	}
	for i := range handles {
		handles[i](request)
	}
}

func BusinessHandle(request Request) {
	login := request.(*Login)
	fmt.Println(login.Username.Sex, login.Password)
}

func Xml() {
	xmlDoc := `<?xml version="1.0" encoding="UTF-8"?>
                <note>
                  <to>Tove</to>
                  <from>Jani</from>
                  <heading>Reminder</heading>
                  <body>Don't forget me this weekend!</body>
                </note>`
	type xmlStruct struct {
		//XMLName xml.Name `xml:"note"`
		To      string `xml:"to"`
		From    string `xml:"from"`
		Heading string `xml:"heading"`
		Body    string `xml:"body"`
	}
	x := xmlStruct{}
	err := xml.Unmarshal([]byte(xmlDoc), &x)
	if err != nil {
		fmt.Println(err.Error())
	} else {
		fmt.Println(x.Body)
	}
}

func main() {
	fmt.Println(0.001 + 0.002)
	Xml()
	request := []byte(`<?xml version="1.0" encoding="utf-8"?>
	<login>
		<username>
			<name>admin</name>
			<sex>男</sex>
		</username>
		<password>123456</password>
	</login>`)
	NetHandle(request, &Login{}, BusinessHandle)

	conn, err := net.Dial("tcp", "127.0.0.1:50000")
	if err != nil {
		panic(err)
	}
	//bw := bufio.NewWriter(conn)
	// bw.Write([]byte{0x00, 0xe6, 0xd0, 0x41, 0x00, 0x01, 0x00, 0xe0, 0x10, 0x41, 0x00, 0x94, 0x11, 0x5e, 0x94, 0x81,
	// 	0x89, 0x95, 0x4b, 0x85, 0xa7, 0x85, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
	// 	0x40, 0x40, 0xf1, 0xf9, 0xc3, 0xc3, 0xf0, 0xf6, 0xc1, 0xc3, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00,
	// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xf0, 0xf0,
	// 	0xf0, 0xf1, 0xd2, 0xc1, 0xd5, 0xd9, 0xc9, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
	// 	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
	// 	0xd6, 0xd5, 0xc5, 0x40, 0x40, 0x40, 0x40, 0x40, 0xf0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
	// 	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xf0, 0xf0, 0xf1, 0xa2, 0xf2, 0xf0, 0xf1,
	// 	0xf1, 0xf0, 0xf1, 0xf1, 0xf4, 0xf0, 0xf0, 0x40, 0x40, 0x40, 0x40, 0xf0, 0x40, 0x40, 0x00, 0x1c,
	// 	0x14, 0x04, 0x14, 0x03, 0x00, 0x0a, 0x24, 0x07, 0x00, 0x0b, 0x14, 0x74, 0x00, 0x05, 0x24, 0x0f,
	// 	0x00, 0x0c, 0x14, 0x40, 0x00, 0x0a, 0x1c, 0x08, 0x04, 0xb8, 0x00, 0x0d, 0x11, 0x47, 0xd8, 0xc4,
	// 	0xc2, 0xf2, 0x61, 0xd5, 0xe3, 0xf6, 0xf4, 0x00, 0x13, 0x11, 0x6d, 0xc4, 0xc5, 0xe2, 0xd2, 0xe3,
	// 	0xd6, 0xd7, 0x60, 0xe3, 0xe2, 0xf0, 0xc8, 0xc1, 0xe5, 0xc1, 0x00, 0x0c, 0x11, 0x5a, 0xe2, 0xd8,
	// 	0xd3, 0xf1, 0xf1, 0xf0, 0xf5, 0xf5, 0x00, 0x4a, 0xd0, 0x01, 0x00, 0x02, 0x00, 0x44, 0x10, 0x6d,
	// 	0x00, 0x06, 0x11, 0xa2, 0x00, 0x09, 0x00, 0x16, 0x21, 0x10, 0xd6, 0xd5, 0xc5, 0x40, 0x40, 0x40,
	// 	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x24, 0x11, 0xdc,
	// 	0x48, 0xef, 0x67, 0x0e, 0x61, 0xe9, 0x8c, 0x6d, 0x84, 0x8b, 0xa4, 0x46, 0x1f, 0x96, 0x2d, 0x9e,
	// 	0xfa, 0x8b, 0xce, 0x08, 0xf1, 0xa6, 0x1e, 0xc0, 0x68, 0x87, 0x0b, 0x5d, 0x19, 0x87, 0x14, 0xb8})
	// DDM
	//bw.WriteByte(0x00) // Length
	//bw.WriteByte(0xD0) // Magic
	//bw.Flush()
	conn.Write(
		WriteDDM(0xd0, 0x41, 1, EXCSAT,
			// WriteParameter(0x115e, []byte{0x94, 0x81,
			// 	0x89, 0x95, 0x4b, 0x85, 0xa7, 0x85, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
			// 	0x40, 0x40, 0xf1, 0xf9, 0xc3, 0xc3, 0xf0, 0xf6, 0xc1, 0xc3, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00,
			// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xf0, 0xf0,
			// 	0xf0, 0xf1, 0xd2, 0xc1, 0xd5, 0xd9, 0xc9, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
			// 	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
			// 	0xd6, 0xd5, 0xc5, 0x40, 0x40, 0x40, 0x40, 0x40, 0xf0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
			// 	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xf0, 0xf0, 0xf1, 0xa2, 0xf2, 0xf0, 0xf1,
			// 	0xf1, 0xf0, 0xf1, 0xf1, 0xf4, 0xf0, 0xf0, 0x40, 0x40, 0x40, 0x40, 0xf0, 0x40, 0x40}),
			WriteParameter(EXTNAM, ToEBCDIC([]byte("QDB2/NT64"))),
			WriteParameter(MGRLVLLS, []byte{0x14, 0x03, 0x00, 0x0a, 0x24, 0x07, 0x00, 0x0b, 0x14, 0x74, 0x00, 0x05, 0x24, 0x0f,
				0x00, 0x0c, 0x14, 0x40, 0x00, 0x0a, 0x1c, 0x08, 0x04, 0xb8}),
			WriteParameter(SRVCLSNM, ToEBCDIC([]byte("QDB2/NT64"))),
			WriteParameter(SRVNAM, ToEBCDIC([]byte("DESKTOP-TS0HAVA"))),
			WriteParameter(SRVRLSLV, ToEBCDIC([]byte("SQL11055"))),
		),
	)
	conn.Write(
		WriteDDM(0xd0, 0x01, 2, ACCSEC,
			WriteParameter(SECMEC, []byte{0x00, 0x09}),
			WriteParameter(RDBNAM, []byte{0xd6, 0xd5, 0xc5, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40}),
			WriteParameter(SECTKN, []byte{0xa2, 0x04, 0x1b, 0x29, 0x03, 0x46, 0xfc, 0x6c, 0xa3, 0x0e, 0xc9, 0x4b, 0xa2, 0xd3, 0x28, 0x5f, 0x5a, 0x99, 0xa8, 0x1c, 0xd2, 0x89, 0x80, 0xbf, 0x80, 0x09, 0xc8, 0x92, 0x32, 0x79, 0xdd, 0x02}),
		),
	)

	drda, _ := ReadDrda(conn)
	fmt.Println(string(toAscii(drda.Parameter[4].Payload)))
	fmt.Println()
	drda, _ = ReadDrda(conn)
	fmt.Println(drda)
	conn.Close()
	// fmt.Printf("% x", WriteDDM(0xd0, 0x41, 1, 0x1041,
	// 	WriteParameter(0x115e, []byte{0x94, 0x81,
	// 		0x89, 0x95, 0x4b, 0x85, 0xa7, 0x85, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
	// 		0x40, 0x40, 0xf1, 0xf9, 0xc3, 0xc3, 0xf0, 0xf6, 0xc1, 0xc3, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00,
	// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xf0, 0xf0,
	// 		0xf0, 0xf1, 0xd2, 0xc1, 0xd5, 0xd9, 0xc9, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
	// 		0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
	// 		0xd6, 0xd5, 0xc5, 0x40, 0x40, 0x40, 0x40, 0x40, 0xf0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
	// 		0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xf0, 0xf0, 0xf1, 0xa2, 0xf2, 0xf0, 0xf1,
	// 		0xf1, 0xf0, 0xf1, 0xf1, 0xf4, 0xf0, 0xf0, 0x40, 0x40, 0x40, 0x40, 0xf0, 0x40, 0x40}),
	// 	WriteParameter(0x1404, []byte{0x14, 0x03, 0x00, 0x0a, 0x24, 0x07, 0x00, 0x0b, 0x14, 0x74, 0x00, 0x05, 0x24, 0x0f,
	// 		0x00, 0x0c, 0x14, 0x40, 0x00, 0x0a, 0x1c, 0x08, 0x04, 0xb8}),
	// 	WriteParameter(0x1147, ToEBCDIC([]byte("QDB2/NT64"))),
	// 	WriteParameter(0x116d, ToEBCDIC([]byte("DESKTOP-TS0HAVA"))),
	// 	WriteParameter(0x115a, ToEBCDIC([]byte("SQL11055"))),
	// ))
}

func ToEBCDIC(data []byte) []byte {
	var buf = bytes.NewBuffer(make([]byte, 0, len(data)))
	for i := range data {
		buf.WriteByte(ebcdic[data[i]])
	}
	return buf.Bytes()
}

func toAscii(data []byte) []byte {
	var buf = bytes.NewBuffer(make([]byte, 0, len(data)))
	for i := range data {
		buf.WriteByte(ascii[data[i]])
	}
	return buf.Bytes()
}

type DRDA struct {
	DDM       DDM
	Parameter []Parameter
}

type DDM struct {
	Length    int32
	Magic     byte
	Format    byte
	CorrelId  int32
	Length2   int32
	CodePoint int32
}

type Parameter struct {
	Length    int32
	CodePoint int32
	Payload   []byte
}

func bytesToInt32(bytes ...byte) int32 {
	if len(bytes) != 2 {
		return 0
	}
	return (int32(bytes[0]) << 8) | int32(bytes[1])
}

// readByte 读取单个 byte
func readByte(br *bytes.Reader) byte {
	b, _ := br.ReadByte()
	return b
}

// readInt32 读取两个 byte
func readInt32(br *bytes.Reader) int32 {
	b1, _ := br.ReadByte()
	b2, _ := br.ReadByte()
	return (int32(b1) << 8) | int32(b2)
}

// readBytes 读取多个 byte
func readBytes(br *bytes.Reader, length int) []byte {
	var b = make([]byte, length)
	br.Read(b)
	return b
}

func ReadDrda(conn net.Conn) (DRDA, error) {
	var b1 = make([]byte, 2)
	conn.Read(b1)
	var length = bytesToInt32(b1...)
	var b2 = make([]byte, length-2)
	n, err := conn.Read(b2)
	if err != nil {
		return DRDA{}, err
	}
	if n != int(length-2) {
		return DRDA{}, errors.New("Read DRDA payload not enough length")
	}
	var ddm = DDM{
		Length:    length,
		Magic:     b2[0],
		Format:    b2[1],
		CorrelId:  bytesToInt32(b2[2], b2[3]),
		Length2:   bytesToInt32(b2[4], b2[5]),
		CodePoint: bytesToInt32(b2[5], b2[6]),
	}
	var drda = DRDA{
		DDM:       ddm,
		Parameter: make([]Parameter, 0),
	}
	for i := 8; i < len(b2); {
		var pl = bytesToInt32(b2[i], b2[i+1])
		drda.Parameter = append(drda.Parameter,
			Parameter{
				Length:    pl,
				CodePoint: bytesToInt32(b2[i+2], b2[i+3]),
				Payload:   b2[i+4 : i+int(pl)],
			},
		)
		i += int(pl)
	}
	return drda, nil
}

func WriteDDM(magic byte, format byte, correlId int32, codePoint int32, parameter ...[]byte) []byte {
	var buf = bytes.NewBuffer(make([]byte, 0))
	buf.WriteByte(0x00)
	buf.WriteByte(0x00)   // Length
	buf.WriteByte(magic)  // Magic
	buf.WriteByte(format) // Format
	buf.WriteByte(byte((correlId & 0xFF00) >> 8))
	buf.WriteByte(byte(correlId & 0x00FF)) // CorrelId
	buf.WriteByte(0x00)
	buf.WriteByte(0x00) // Length2
	buf.WriteByte(byte((codePoint & 0xff00) >> 8))
	buf.WriteByte(byte(codePoint & 0x00ff)) // codePoint
	for i := range parameter {
		buf.Write(parameter[i])
	}
	var b = buf.Bytes()
	var l1 = len(b)
	b[0] = byte((l1 & 0xff00) >> 8) // Length
	b[1] = byte(l1 & 0x00ff)
	b[6] = byte(((l1 - 6) & 0xff00) >> 8) // Length2
	b[7] = byte((l1 - 6) & 0x00ff)
	return b
}

func WriteParameter(codePoint int32, payload []byte) []byte {
	var buf = bytes.NewBuffer(make([]byte, 0))
	buf.WriteByte(0x00)
	buf.WriteByte(0x00) // Length
	buf.WriteByte(byte((codePoint & 0xff00) >> 8))
	buf.WriteByte(byte(codePoint & 0x00ff)) // CodePoint
	buf.Write(payload)                      // Payload
	var b = buf.Bytes()
	var l = len(b)
	b[0] = byte((l & 0xff00) >> 8)
	b[1] = byte(l & 0x00ff)
	return b
}

// int ddm_write_rqsdss(DRDA *drda, int typ)
// {
//     unsigned char *buf;

// 	buf = &drda->out_buf[drda->out_pos];

// 	memset(buf, 0, 2); /* zero the length, to be written later */
// 	buf[2] = 0xd0;   /* DDMID */
// 	buf[3] = typ;   /* A simple request message */
// 	if ( (typ&0x10) == 0 ) ++drda->rqscrr;
// 	drda_put_int2(&buf[4], 42); //drda->rqscrr);  /* correlation id */
// 	drda->out_pos += 6;

// 	return 6;
// }
